local sim = alife()

class "need" (property_evaluator)

function need:__init(storage, name, npc, dynQt) super(nil, name)
	self.dyn_qt = dynQt
	self.npc_id = npc:id()
end

function need:evaluate()
	return db.storage[self.npc_id].curr_qsts == self.dyn_qt 
end

class "on_need_point" (property_evaluator)

function on_need_point:__init(storage, name, npc) super(nil, name)
	self.st = storage
	self.object = npc
end

function on_need_point:evaluate()
	return (self.st.purpose) and (self.st.purpose.position:distance_to_sqr(self.object:position()) < 6) or false
end

class "go_target" (action_base)

function go_target:__init (npc, action_name, storage, dynQt) super(nil, action_name)
	self.st = storage
	self.object = npc 
	self.dynQt = dynQt
	self.parent_purpose = false
	self.lastPos = false

end 

function go_target:initialize() 
	action_base.initialize(self)
	self.state = -1 -- 0 go, 1 anim, 2 ?
	printf("@go_target:initialize")
	
	self.lastPos = self.st.purpose.position
	self:goner() 
end

function go_target:goner()
	self.st.dqAnim = false
	self.object:set_desired_position()
	
	self.object:inactualize_patrol_path		()
	
	self.object:set_desired_direction()
	self.object:inactualize_patrol_path()
	self.object:set_body_state(move.standing)
	self.object:set_detail_path_type(move.line)
	self.object:set_mental_state(anim.danger)
	self.object:set_movement_selection_type(game_object.alifeMovementTypeMask)
	self.object:set_movement_type(move.run)
	self.object:set_path_type(game_object.game_path)
	self.object:set_sight(look.path_dir, nil, 0)
	state_mgr.set_state (self.object, "run")
	
	--self.object:set_path_type           	( game_object.game_path )
	self:get_path()
end

function go_target:get_path()
	printf("#get_path")
	if game_graph():vertex(self.st.purpose.m_game_vertex_id):level_id() == game_graph():vertex(self.object:game_vertex_id()):level_id() then
		self.object:set_path_type(game_object.level_path)
		utils.send_to_nearest_accessible_vertex(self.object, self.st.purpose.m_level_vertex_id, "xr_mytest:1")
		self.object:set_desired_position(self.st.purpose.position)
	else
		self.object:set_dest_game_vertex_id		( self.st.purpose.m_game_vertex_id)
		self.object:set_path_type ( game_object.game_path )
	end
	self.object:set_sight					(look.path_dir, nil, 0)
	self.state = 0
	state_mgr.set_state (self.object, 'run')
end

function go_target:anim_end()
	get_console():execute("anim_end")
	self.state = 2

end

function go_target:anim()
	self.object:set_desired_position()
	self.object:set_desired_direction()
	
	--local cb = {obj = self, func = self.anim_end, timeout=15000} 
	--local anm = 'search' --xr_logic.pick_section_from_condlist(db.actor, self.object, self.st.anm)
	--state_mgr.set_state(self.object, anm, cb, 0, {look_position = self.st.purpose.position})
	self.state = 1
	
	self.dynQt:step(self)
	printf("EVENT!")
end

function go_target:execute()
	action_base.execute(self)
	
	if self.st.purpose then
		if (self.st.obj_purpose.parent_id ~= 65535) and (self.st.purpose == self.st.obj_purpose) then 
			self.st.purpose = sim:object(self.st.purpose.parent_id)
			printf("~new|self.st.purpose|"..self.st.purpose.id)
			self.parent_purpose = true
		elseif (self.st.obj_purpose.parent_id == 65535) and (self.st.purpose ~= self.st.obj_purpose) then
			self.st.purpose = self.st.obj_purpose
			printf("~old|self.st.purpose")
			self.parent_purpose = false
		end
	
		if self.dynQt:conder(self) then
			if self.state ~= 1 then
				self:anim()
			end
		elseif (self.state ~= 0) or (self.lastPos:distance_to_sqr(self.st.purpose.position) >1) then
			--state_mgr.set_state (self.object, "run")
			self:get_path()
			printf("#goner")
			self.lastPos = self.st.purpose.position
		end
	end
end

class "wait_action" (action_base)

function wait_action:__init (npc, action_name, storage) super(nil, action_name)
	self.st = storage
	self.object = npc
	self.st.dqAnim = false
end

function wait_action:initialize()
	action_base.initialize(self) 
end

function wait_action:activate_scheme()
	
end

function wait_action:time_callback()
	self.st.dqAnim = true
end

function wait_action:execute ()
	action_base.execute(self)
	get_console():execute("initialize_wait_action")
end

class "end_anim" (property_evaluator)

function end_anim:__init(storage, name) super(nil, name)
	self.st = storage
end

function end_anim:evaluate()
	return true
end

class "eva_property_alife"  ( property_evaluator )
function eva_property_alife:__init( name, npc, dynQt) super ( nil, name )
	self.dyn_qt = dynQt
	self.npc_id = npc:id()
end

function eva_property_alife:evaluate()
	return db.storage[self.npc_id].curr_qsts == self.dyn_qt 
end 


function add_to_binder(npc, ini, scheme, section, storage, dynQt)
	printf("@add_to_binder")
	local operators	= {}
	local properties  = {}

	local manager = npc:motivation_action_manager()
	
	operators["act_point"] = xr_evaluators_id.zmey_remark_base + 2
	operators["anims"] = xr_evaluators_id.zmey_remark_base + 3
	
	properties["has"] = xr_actions_id.zmey_remark_base + 4
	properties["at_point"]  = xr_actions_id.zmey_remark_base + 5
	properties["anim_end"] = xr_actions_id.zmey_remark_base + 6
	properties["state_mgr_logic_active"] 	= xr_evaluators_id.state_mgr + 4
		 -- evaluators
	manager:add_evaluator(properties["has"], this.need(storage, "has_uniq_uniq", npc, dynQt))
	manager:add_evaluator(properties["at_point"], this.on_need_point(storage, "on_need_point_uniq", npc))
	manager:add_evaluator(properties["anim_end"], this.end_anim(storage, "anim_end"))

	--local new_action2 = this.wait_action(npc, "wait_action_uniq", storage)
	--new_action2:add_precondition(world_property(stalker_ids.property_alive, true))
	--new_action2:add_precondition(world_property(stalker_ids.property_danger, false))
	--new_action2:add_precondition(world_property(stalker_ids.property_enemy, false))
	--new_action2:add_precondition(world_property(stalker_ids.property_anomaly, false))
	--modules.add_common_precondition(scheme, new_action2) 
	--
	--new_action2:add_precondition(world_property(properties["has"], true))
	--new_action2:add_precondition(world_property(properties["at_point"], true))
	--manager:add_action(operators["anims"], new_action2) 

	local new_action = this.go_target(npc, "go_target_uniq", storage, dynQt)
	new_action:add_precondition(world_property(stalker_ids.property_alive, true))
	new_action:add_precondition(world_property(stalker_ids.property_danger, false))
	new_action:add_precondition(world_property(stalker_ids.property_enemy, false))
	new_action:add_precondition(world_property(stalker_ids.property_anomaly, false))
	modules.add_common_precondition(scheme, new_action)
	
	new_action:add_precondition(world_property(properties["has"], true))
	--new_action:add_precondition(world_property(properties["at_point"], false))
	--new_action:add_effect (world_property(properties["at_point"], true))
	--new_action:add_precondition(world_property(properties["anim_end"], false))
	new_action:add_effect (world_property(properties["has"], false))
	new_action:add_effect (world_property(properties["state_mgr_logic_active"], false))
	manager:add_action(operators["act_point"], new_action)
	
	
	--xr_logic.subscribe_action_for_events(npc, storage, new_action)
	
	--local actionW = manager:action(stalker_ids.action_alife_planner)
	--local action = cast_planner(actionW) --property_alife
	--action:remove_evaluator(stalker_ids.property_alife)
	--action:add_evaluator(stalker_ids.property_alife, eva_property_alife( "reached_task_location", npc, dynQt))

	local action = manager:action(stalker_ids.action_alife_planner)

	action:add_precondition(world_property(properties["has"], false))
	action:add_precondition (world_property(properties["state_mgr_logic_active"], false))
	action:add_effect (world_property(properties["has"], true))
end

function set_scheme(npc, sobj, dynQt)
	xr_logic.reset_generic_schemes_on_scheme_switch(npc, 'pointer', 'pointer')
	
	local id = npc:id()	

	if not db.storage[id] then
		db.storage[id] = {}
	end
	if not db.storage[id]["pointer"] then
		db.storage[id]["pointer"] = {} 
	end
	
	local st = db.storage[id]["pointer"]
	st.npc = npc
	st.logic = {}
	
	this.add_to_binder(npc, ini, "pointer", 'pointer', st, dynQt)


	st.section = "pointer"
	st.ini = ini
	
	--**********************************************************************************--

	--local st = db.storage[id]["pointer"] --xr_logic.assign_storage_and_bind(npc, false, "pointer", 'pointer')
	
	st.logic     = {}

	st.obj_purpose = sobj
	st.purpose = sobj
	st.finish = false
	
	return function (newPurposeId, finish)
		if finish then
			local bind = npc:binded_object()
			bind.updDynQuest = function() end
			st.finish = true
			db.storage[id].active_section = nil
			db.storage[id].active_scheme = nil
			db.storage[npc:id()].curr_qsts = false
			printf("~finish")
			return st.finish
		else
			st.obj_purpose = sim:object(newPurposeId) 
			st.purpose = st.obj_purpose
			return true
		end
	end
	

	--[[
	st.snd			= ini:r_string_ex(section,"snd")
	st.anm			= xr_logic.parse_condlist(npc, "anim", "anim", ini:r_string_ex(section,"anim") or "wait")
	st.tips_id		= ini:r_string_ex(section,"tips")
	if st.tips_id then
		st.sender	= ini:r_string_ex(section,"tips_sender")
	end
	st.target = ini:r_string_ex(section,"target") or "nil"
	st.target_id = nil
	st.target_position = nil
	]]
end

