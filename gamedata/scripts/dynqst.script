local sim = alife()

class "DynQuest" 

--[[
	type_work:
	0 - Забрать предмет.
	1 - Ликвидация.
	2 - Приблизится (имитация взаимодействия).
	3 - Сопровождение.
]]

function DynQuest:__init(id, executor, employer)
	local task_ini 		= task_manager.task_ini
	
	self.executor		= executor -- Исполнитель -и
	self.target			= task_ini:r_string_ex(id, "target")
	self.target			= xr_logic.parse_condlist(self.executor, "task", "task_condlist", self.target)
	self.type_work		= type_work
	self.employer		= employer -- работодатель
	self.keeper			= self.employer  -- храниль -и
	--self.currentTargetId
		
	self.mystate			= 0
	self.switcher			= false
		
	self.currAction		= dtask_actions.rtrue  -- ф-ция которая выполнится если условие достижения цели выполнено, должно возвратить true чтобы учесть дейтвие выполненным и разрешить переключение на следующие цели (сделать шаг)
	self.conder				= dtask_actions.def_conder -- Ф-ция - условие для состояния достижения цели 
	
	self._strTarget	= self:targetParser() -- строка: стори ИД цели
	
	local i = 0
	self.condlist = {}
	while task_ini:line_exist(id, "condlist_"..tostring(i)) do
		table.insert(self.condlist,
			xr_logic.parse_condlist(self.executor, "dynqst.DynQuest", "self.condlist", task_ini:r_string_ex(id, "condlist_"..tostring(i)))
		)
		i = i + 1
	end
	printf('!condlist|%s', tostring(#self.condlist))
	return self
end

function DynQuest:targetParser()
	if self.mystate == 0 then
		self.currentTargetId = self.employer.id
		return self.currentTargetId
	end
	
	local strTarget = xr_logic.pick_section_from_condlist(db.actor, self.executor, self.target) -- Парсятся цели из строки {+infp -infp =fun !fun} section %+infp -infp =fun%
	if self._strTarget == strTarget then
		return strTarget
	end
		
	self._strTarget = strTarget
	local hndlr, conder = 'rtrue', 'def_conder'
	local targetStoryId
	
	if string.find(self._strTarget, "|") then 
		targetStoryId, hndlr = string.match(self._strTarget, "(.+)[|](.+)")
		
		if string.find(targetStoryId, "|") then
			targetStoryId, conder = string.match(targetStoryId, "(.+)[|](.+)")
		end
	end
	 
	self.currAction = dtask_actions[hndlr]
	self.conder = dtask_actions[conder]
	
	self.currentTargetId = get_story_object_id(targetStoryId)
	return targetStoryId
end

function DynQuest:changeTarget (id)
	self.currentTargetId = id
	self.switcher(self.currentTargetId)
end

function DynQuest:step(logic)
	log("~STEP|"..tostring(self.mystate))
	
	if self.mystate > 0 then 
		if self:currAction() then 
			self.mystate = self.mystate + 1
		end 
	else
		self.switcher(self.currentTargetId) 
		self.mystate = self.mystate + 1
	end
end

function DynQuest:progress(act)
	--log ('progress|'..tostring(act))
	if not act then return end
		
	if act == "complete" then	
		log "~complete"
		self.switcher(_, true)
	elseif act == "fail" then 
		self.switcher(_, true)
	elseif act == "reversed" then
		self.switcher(_, true)
	end
end
-- updDynQuest
-- dyn_qsts
function DynQuest:update(binder) 	
	if not self then return abort("dynqst:70") end

	local t_target = self:targetParser()
	if not t_target then
		return abort("DynQst: new target parsing as nil!") 
	end
	
	if self.currentTargetId ~= t_target then
		self:changeTarget(self.currentTargetId) 
	end

	for i=1, #self.condlist do
		self:progress( xr_logic.pick_section_from_condlist(db.actor, self.executor, self.condlist[i]) )
	end
end

function DynQuest:set_state()
	db.storage[self.executor:id()].currDynQuest = self 
	self.switcher = self:setLogic()
	
	local bind = self.executor:binded_object()
	bind.updDynQuest = function(binder)
		return self:update(binder)
	end
end

function DynQuest:setLogic()  
	local npc_id = self.executor
	
	if not db.storage[npc_id] then
		db.storage[npc_id] = {}
	end

	if db.storage[npc_id].active_scheme then
		xr_logic.issue_event(self.executor, db.storage[npc_id][db.storage[npc_id].active_scheme], "deactivate", self.executor)
	end
	
	if db.storage[npc_id].overrides then
		db.storage[npc_id].overrides = nil
	end

	local scheme, section, filename = "pointer", "pointer", 'xr_targeter'
	modules.reset_generic_schemes(self.executor, scheme, section)
	db.storage[npc_id].overrides = nil
	db.storage[npc_id].activation_time = time_global()
	db.storage[npc_id].activation_game_time = game.get_game_time()
	local a = _G[filename].set_scheme(self.executor, self.employer, self)

	db.storage[npc_id].active_section = section
	db.storage[npc_id].active_scheme = scheme
	
	xr_logic.issue_event(self.executor, db.storage[npc_id][scheme], "activate_scheme", false, self.executor)
	return a
end

