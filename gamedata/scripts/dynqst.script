local sim = alife()

db = {}

class "DynQuest" 

--[[ --TODO
	type_work:
	0 - Забрать предмет.
	1 - Ликвидация.
	2 - Приблизится (имитация взаимодействия).
	3 - Сопровождение.
]] --TODO

function DynQuest:__init(id, executor, employer, subject)
	local task_ini 		= task_manager.task_ini
	
	self.executor		= executor -- Исполнитель
	self.target			= task_ini:r_string_ex(id, "target")
	self.target			= xr_logic.parse_condlist(self.executor, "task", "task_condlist", self.target)
	self.type_work		= type_work --TODO
	self.employer		= employer -- работодатель
	self.keeper			= self.employer  -- храниль -и
	self.storage		= {}  -- Хранилище свободных данных для квеста
	self.subject		= subject  -- Субъект квеста (server object)
	--self.currentTargetId
		
	self.mystate		= 0
	self.switcher		= false
		
	self.effector		= dtask_actions.rtrue  -- ф-ция которая выполнится если условие достижения цели выполнено, должно возвратить true чтобы учесть дейтвие выполненным и разрешить переключение на следующие цели (сделать шаг)
	self.conder			= dtask_actions.def_conder -- Ф-ция - условие для состояния достижения цели 
	
	self._strTarget, self.currentTargetId = self:targetParser() -- строка: стори ИД цели
	
	self.condlist 		= {}
	
	if task_ini:line_exist(id, "condlist") then
		table.insert(self.condlist, xr_logic.parse_condlist(self.executor, "dynqst.DynQuest", "self.condlist", task_ini:r_string_ex(id, "condlist")) )
	end
	local i = 1
	while task_ini:line_exist(id, "condlist_"..tostring(i)) do
		table.insert(self.condlist,
			xr_logic.parse_condlist(self.executor, "dynqst.DynQuest", "self.condlist", task_ini:r_string_ex(id, "condlist_"..tostring(i)))
		)
		i = i + 1
	end
	return self
end

do
	local strTarget, effector, conder, targetStoryId
	function DynQuest:targetParser()
		if self.mystate == 0 then
			self.currentTargetId = self.employer.id
			return "", self.currentTargetId
		end
		
		strTarget = xr_logic.pick_section_from_condlist(db.actor, self.executor, self.target) -- Парсятся цели из строки {+infp -infp =fun !fun} section %+infp -infp =fun%

		if self._strTarget == strTarget then
			return strTarget, self.currentTargetId
		end

		effector, conder = 'rtrue', 'def_conder'
		
		if string.find(strTarget, "|") then 
			targetStoryId, effector = string.match(strTarget, "(.+)[|](.+)")
			
			if string.find(targetStoryId, "|") then
				targetStoryId, conder = string.match(targetStoryId, "(.+)[|](.+)")
			end
		end
		 
		self.effector = dtask_actions[effector]
		self.conder = dtask_actions[conder]
		
		return targetStoryId, get_story_object_id(targetStoryId)
	end
end

function DynQuest:changeTarget (id, str)
	self.currentTargetId = id
	self._strTarget = str
	self.switcher(self.currentTargetId)
end

function DynQuest:step(logic)
	log("~STEP|"..tostring(self.mystate))
	
	if self.mystate > 0 then 
		if self:effector() then 
			self.mystate = self.mystate + 1
		end 
	else
		self.mystate = self.mystate + 1
	end
end

function DynQuest:progress(act)
	if not act then return end
		
	if act == "complete" then	
		log "~complete"
		self.switcher(_, true)
	elseif act == "fail" then 
		self.switcher(_, true)
	elseif act == "reversed" then
		self.switcher(_, true)
	end
end

do
	local str_targetSid, targetId
	function DynQuest:update() 	
		if not self then return abort("dynqst:70") end

		str_targetSid, targetId = self:targetParser()
		if not (str_targetSid and targetId) then
			return abort("DynQst: new target parsing as nil!") 
		end
		
		if self._strTarget ~= str_target then
			self:changeTarget(targetId, str_targetSid) 
		end

		for i=1, #self.condlist do
			self:progress( xr_logic.pick_section_from_condlist(db.actor, self.executor, self.condlist[i]) )
		end
	end
end

function DynQuest:set_state() 
	local npc_id = self.executor:id()
	if not db.storage[npc_id] then
		db.storage[npc_id] = {}
	end

	local bind = self.executor:binded_object()
	bind.updDynQuest = function(binder)
		return self:update()
	end
	
	--db.storage[].currDynQuest = self
	dynqst.db[npc_id] = self
	
	self.switcher = self:setLogic()
end

function DynQuest:shutdown()
	local bind = self.executor:binded_object()
	bind.updDynQuest = function() end
	
	--db.storage[self.executor:id()].currDynQuest = nil
	dynqst.db[npc_id] = nil
end

local scheme, section, filename = "pointer", "pointer", 'xr_targeter'

function DynQuest:deactivateScheme(st)
	--************************************************* part code from xr_logic.switch_to_section
	local npc_id = self.executor:id()
	
	if (axr_beh) then utils.save_var(self.executor, "path_index",1) end

	st = st or db.storage[npc_id]["pointer"] -- моё 
	xr_logic.issue_event(self.executor, st, "deactivate", self.executor, st)
	
	db.storage[npc_id].exit_from_smartcover_initialized = nil
	db.storage[npc_id].active_section = nil
	db.storage[npc_id].active_scheme = nil
	
	return true
end

function DynQuest:toOffline(sobj)
	return xr_targeter.onOffline(sobj)
end

function DynQuest:setLogic()  
	local npc_id = self.executor:id()
	
	self:deactivateScheme()
	--************************************************ part code from xr_logic.activate_by_section
	db.storage[npc_id].activation_time = time_global()
	db.storage[npc_id].activation_game_time = game.get_game_time()

	-- Сбросить общие схемы:
	xr_logic.reset_generic_schemes_on_scheme_switch(self.executor, scheme, section)

	local logicCallback = _G[filename].set_scheme(self.executor, sim:object(self.currentTargetId), self)

	db.storage[npc_id].active_section = section
	db.storage[npc_id].active_scheme = scheme

	-- чтобы избежать дальнейшего движения по пути при установке рестрикторов
	--self.executor:inactualize_patrol_path() -- Alundaio: Necessary to clear path data or self.executor can get stuck on generic schemes
	--self.executor:set_path_type(game_object.level_path)
	--utils.send_to_nearest_accessible_vertex(self.executor, self.executor:level_vertex_id(), "dynqst.DynQuest:setLogic")

	xr_logic.issue_event(self.executor, db.storage[npc_id][scheme], "activate_scheme", false, self.executor)

	return logicCallback
end

--**************************************************************************************************************************--
--**************************************************************************************************************************--

function Load(reader)
	local dybQuest = reader:r_stringZ()
end

function Save(packet, dybQuest)
	return packet:w_stringZ(dybQuest)
end

